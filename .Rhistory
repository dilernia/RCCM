}
return(mll)
}
modelLogLikelihood2 <- function(omegaks, omega0s, ws, x, lambda2) {
G <- dim(omega0s)[3]
K <- dim(omegaks)[3]
mll <- 0
for(k in 1:K) {
lk1 <- sum(mvtnorm::dmvnorm(x[[k]], sigma = solve(omegaks[, , k]), log = T))
lk2 <- log(sum(sapply(1:G, FUN = function(g) {
exp(log(ws[g, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , g], logged = T, nu = lambda2))})))
mll <- mll + lk1 + lk2
}
return(mll)
}
modelLogLikelihood(omegaks = omegaks, omega0s = omega0s, ws = ws, x = x, lambda2 = lambda2)
modelLogLikelihood2(omegaks = omegaks, omega0s = omega0s, ws = ws, x = x, lambda2 = lambda2)
exp(-Inf)
exp(log(ws[g, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , g], logged = T, nu = lambda2))
exp(log(ws[1, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , 1], logged = T, nu = lambda2))
exp(log(ws[2, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , 2], logged = T, nu = lambda2))
exp(log(ws[1, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , 1], logged = T, nu = lambda2))
log(ws[1, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , 1], logged = T, nu = lambda2)
log(ws[2, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , 2], logged = T, nu = lambda2)
exp(log(ws[1, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , 1], logged = T, nu = lambda2))
exp(log(ws[2, k]) + rccm::dwishart(omegaks[, , k], M = omega0s[, , 2], logged = T, nu = lambda2))
modelLogLikelihood(omegaks = omegaks, omega0s = omega0s, ws = ws, x = x, lambda2 = lambda2)
ws[g, k] * rccm::dwishart(omegaks[, , k], M = omega0s[, , g], logged = FALSE, nu = lambda2)
ws[1, k] * rccm::dwishart(omegaks[, , k], M = omega0s[, , 1], logged = FALSE, nu = lambda2)
ws[1, k]
rccm::dwishart(omegaks[, , k], M = omega0s[, , 1], logged = T, nu = lambda2)
exp(-1050.384)
log(0)
log(exp(-1050.384))
log(exp(-1050.384))
modelLogLikelihood <- function(omegaks, omega0s, ws, x, lambda2) {
G <- dim(omega0s)[3]
K <- dim(omegaks)[3]
mll <- 0
for(k in 1:K) {
lk1 <- sum(mvtnorm::dmvnorm(x[[k]], sigma = solve(omegaks[, , k]), log = T))
if(any(ws[, k] == 1)) {
lk2 <- rccm::dwishart(omegaks[, , k], M = omega0s[, , which(ws[, k] == 1)], logged = T, nu = lambda2)
} else {
lk2 <- log(sum(sapply(1:G, FUN = function(g) {
ws[g, k] * rccm::dwishart(omegaks[, , k], M = omega0s[, , g], logged = F, nu = lambda2)})))
mll <- mll + lk1 + lk2
}
}
return(mll)
}
rccm::dwishart(omegaks[, , k], M = omega0s[, , 1], logged = T, nu = lambda2)
modelLogLikelihood(omegaks = omegaks, omega0s = omega0s, ws = ws, x = x, lambda2 = lambda2)
G <- dim(omega0s)[3]
K <- dim(omegaks)[3]
mll <- 0
k = 1
lk1 <- sum(mvtnorm::dmvnorm(x[[k]], sigma = solve(omegaks[, , k]), log = T))
lk1
lk2 <- rccm::dwishart(omegaks[, , k], M = omega0s[, , which(ws[, k] == 1)], logged = T, nu = lambda2)
lk2
mll <- mll + lk1 + lk2
mll
modelLogLikelihood <- function(omegaks, omega0s, ws, x, lambda2) {
G <- dim(omega0s)[3]
K <- dim(omegaks)[3]
mll <- 0
for(k in 1:K) {
lk1 <- sum(mvtnorm::dmvnorm(x[[k]], sigma = solve(omegaks[, , k]), log = T))
if(any(ws[, k] == 1)) {
lk2 <- rccm::dwishart(omegaks[, , k], M = omega0s[, , which(ws[, k] == 1)], logged = T, nu = lambda2)
mll <- mll + lk1 + lk2
} else {
lk2 <- log(sum(sapply(1:G, FUN = function(g) {
ws[g, k] * rccm::dwishart(omegaks[, , k], M = omega0s[, , g], logged = F, nu = lambda2)})))
mll <- mll + lk1 + lk2
}
}
return(mll)
}
modelLogLikelihood(omegaks = omegaks, omega0s = omega0s, ws = ws, x = x, lambda2 = lambda2)
modelLogLikelihood <- function(omegaks, omega0s, ws, x, lambda2) {
G <- dim(omega0s)[3]
K <- dim(omegaks)[3]
mll <- 0
for(k in 1:K) {
lk1 <- sum(mvtnorm::dmvnorm(x[[k]], sigma = solve(omegaks[, , k]), log = T))
if(any(ws[, k] == 1)) {
lk2 <- rccm::dwishart(omegaks[, , k], M = omega0s[, , which(ws[, k] == 1)], logged = T, nu = lambda2)
mll <- mll + lk1 + lk2
} else {
lk2 <- log(sum(sapply(1:G, FUN = function(g) {
ws[g, k] * rccm::dwishart(omegaks[, , k], M = omega0s[, , g], logged = F, nu = lambda2)})))
mll <- mll + lk1 + lk2
}
}
return(mll)
}
myData <- rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
myData <- rccm::rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
resultRccm <- rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
resultRccm <- rccm::rccm(x = myData$simDat, lambda1 = 20,
lambda2 = 325, lambda3 = 0.01, nclusts = 2)
aic(omegaks = resultRccm$Omegas, omega0s = resultRccm$Omega0,
ws = resultRccm$weights, x = myData$simDat, lambda2 = 325)
aic <- function(omegaks, omega0s, ws, x, lambda2) {
K <- dim(omegaks)[3]
G <- dim(omega0s)[3]
dfks <- sapply(X = 1:K, FUN = function(k) {
sum(rccm::adj(omegaks[, , k])[lower.tri(omegaks[, , k])])
})
dfgs <- sapply(X = 1:G, FUN = function(g) {
sum(rccm::adj(omega0s[, , g])[lower.tri(omega0s[, , g])])
})
modelDim <- sum(c(dfks, dfgs))
mll <- modelLogLikelihood(omegaks = omegaks, omega0s = omega0s, ws = ws, x = x, lambda2 = lambda2)
aic <- 2*modelDim - 2*mll
return(aic)
}
aic(omegaks = resultRccm$Omegas, omega0s = resultRccm$Omega0,
ws = resultRccm$weights, x = myData$simDat, lambda2 = 325)
myData <- rccm::rccSim(G = 2, clustSize = 10, p = 10, n = 100, overlap = 0.50, rho = 0.10)
K <- length(myData$simDat)
p <- ncol(myData$simDat[[1]])
G <- dim(myData$Omega0s)[3]
wMat <- matrix(0, ncol = length(myData$simDat), nrow = G)
for(i in 1:length(myData$zgks)){
wMat[myData$zgks[i], i] <- 1
}
# Using true parameters
aic(myData$Omegaks, myData$Omega0s, wMat, x = myData$simDat, lambda2 = p)
# Using MLEs
aic(sapply(myData$simDat, simplify = "array", FUN = function(datf){solve(cov(datf))}),
myData$Omega0s, wMat, x = myData$simDat, lambda2 = p)
# Using glasso estimates
aic(sapply(myData$simDat, simplify = "array", FUN = function(datf){
pmat <- glasso::glasso(cov(datf), rho = 0.01)$wi
return((pmat + t(pmat)) / 2)}),
myData$Omega0s, wMat, x = myData$simDat, lambda2 = p)
# Trying for different tuning values
candLambs <- seq(0.01, 1, length.out = 100)
aicVals <- sapply(candLambs, FUN = function(lambda1) {
rccm::aicbic(sapply(myData$simDat, simplify = "array", FUN = function(datf){
pmat <- glasso::glasso(cov(datf), rho = lambda1)$wi
return((pmat + t(pmat)) / 2)}),
x = myData$simDat)[1]
})
# Plotting
plot(x = candLambs, y = aicVals, col = 'blue', add = T)
# Trying for different tuning values
candLambs <- seq(0.01, 1, length.out = 100)
aicVals <- sapply(candLambs, FUN = function(lambda1) {
aic(sapply(myData$simDat, simplify = "array", FUN = function(datf){
pmat <- glasso::glasso(cov(datf), rho = lambda1)$wi
return((pmat + t(pmat)) / 2)}), omega0s = myData$Omega0s, ws = wMat,
x = myData$simDat, lambda2 = 10)
})
# Plotting
plot(x = candLambs, y = aicVals, col = 'blue', add = T)
which.min(aicVals)
devtools::document()
devtools::document()
unlink('docs/exampleSimulationRCCM_HighMag_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align="center",
message = F, warning = F)
# Install version of package used for Biostatistics submission
if("rccm" %in% installed.packages() == FALSE) {
devtools::install_github("dilernia/rccm")
}
# Load rcm package
library(rccm)
# Loading other packages
library(tidyverse, quietly = T)
library(kableExtra, quietly = T)
# Display help file
?rccSim
# Simulate data
set.seed(1994)
G <- 2
p <- 10
myData <- rccSim(G = G, clustSize = 20, p = p, n = 177, overlap = 0.20, rho = 0.10)
# Standardizing data
myData$simDat <- lapply(myData$simDat, FUN = scale)
# Display help file
?starsRccm
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(1000, 3000, 5000), lambda3 = 20)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = G, N = 10, method = "RCCM")
myData$simDat
lambdas
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = G, N = 10, method = "RCCM")
View(myData)
?starsRccm
lambdas
G
# Display help file
?starsRccm
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(1000, 3000, 5000), lambda3 = 20)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = G, N = 10, method = "RCCM")
lambdas
unlink('docs/exampleSimulationRCCM_HighMag_cache', recursive = TRUE)
warnings()
# Display help file
?rccSim
# Simulate data
set.seed(1994)
G <- 2
p <- 10
myData <- rccSim(G = G, clustSize = 20, p = p, n = 177, overlap = 0.20, rho = 0.10)
# Standardizing data
myData$simDat <- lapply(myData$simDat, FUN = scale)
# Display help file
?starsRccm
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(1000, 3000, 5000), lambda3 = 20)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = G, N = 10, method = "RCCM")
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
warnings()
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(1000, 3000, 5000), lambda3 = 10)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(1000, 3000, 5000), lambda3 = 5)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(1000, 3000, 5000), lambda3 = 0)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(10, 1000, 3000, 5000), lambda3 = 0)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(100, 300, 500), lambda3 = 0)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
warnings()
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40),
lambda2 = c(1000, 3000, 5000), lambda3 = 5)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40)/10,
lambda2 = c(1000, 3000, 5000), lambda3 = 5)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40)/100,
lambda2 = c(1000, 3000, 5000), lambda3 = 5)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40)/1000,
lambda2 = c(1000, 3000, 5000), lambda3 = 5)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
# Grid of tuning parameters to search over
lambdas <- expand.grid(lambda1 = c(1, 5, 15, 25, 35, 40)/100,
lambda2 = c(1000, 3000, 5000), lambda3 = 5)
# Find optimal tuning parameter set using modified stARS with 10 bootstrap samples
optTune <- starsRccm(datf = myData$simDat, lambs = lambdas, G = 2, N = 10, method = "RCCM")
starsRccm
datf = myData$simDat
lambs = lambdas
N <- 10
method = "RCCM"
beta = 0.05
z0s = NULL
ncores = NULL
ns <- sapply(datf, FUN = nrow)
K <- length(datf)
bs <- sapply(ns, FUN = function(x) {
if (x > 100) {
floor(10 * sqrt(x))
}
else {
floor(0.75 * (x))
}
})
keeper <- function(b, n) {
keepInds <- matrix(NA, nrow = b, ncol = N)
while (ncol(unique(keepInds, MARGIN = 2)) < N) {
for (s in 1:N) {
keepInds[, s] <- sort(sample(x = 1:n, size = b,
replace = FALSE))
}
}
return(keepInds)
}
keepInds <- mapply(FUN = keeper, n = ns, b = bs, SIMPLIFY = FALSE)
if (method == "GLasso") {
lambs <- data.frame(lambda1 = unique(lambs$lambda1),
lambda2 = NA, lambda3 = NA)
}
else if (method %in% c("FGL", "GGL")) {
lambs <- expand.grid(lambda1 = unique(lambs$lambda1),
lambda2 = unique(lambs$lambda2), lambda3 = NA)
}
else if (method %in% c("RCCM", "RCM")) {
lambs <- lambs
}
if (is.null(ncores)) {
ncores <- 1
}
ns <- sapply(datf, FUN = nrow)
K <- length(datf)
bs <- sapply(ns, FUN = function(x) {
if (x > 100) {
floor(10 * sqrt(x))
} else {
floor(0.75 * (x))
}
})
keeper <- function(b, n) {
keepInds <- matrix(NA, nrow = b, ncol = N)
while (ncol(unique(keepInds, MARGIN = 2)) < N) {
for (s in 1:N) {
keepInds[, s] <- sort(sample(x = 1:n, size = b,
replace = FALSE))
}
}
return(keepInds)
}
keepInds <- mapply(FUN = keeper, n = ns, b = bs, SIMPLIFY = FALSE)
if (method == "GLasso") {
lambs <- data.frame(lambda1 = unique(lambs$lambda1),
lambda2 = NA, lambda3 = NA)
} else if (method %in% c("FGL", "GGL")) {
lambs <- expand.grid(lambda1 = unique(lambs$lambda1),
lambda2 = unique(lambs$lambda2), lambda3 = NA)
} else if (method %in% c("RCCM", "RCM")) {
lambs <- lambs
}
if (is.null(ncores)) {
ncores <- 1
}
ncores
starNets <- lapply(1:N, FUN = function(i) {
subDats <- lapply(1:K, FUN = function(k) {
datf[[k]][keepInds[[k]][, i], ]
})
if (ncores > 1) {
`%dopar%` <- foreach::`%dopar%`
cl <- parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)
nets <- foreach::foreach(t = 1:nrow(lambs), .export = c("method",
"G", "K", "lambs", "z0s")) %dopar%
{
listRes <- NULL
tryCatch({
if (method == "RCCM") {
arrayRes <- rccm(subDats, lambda1 = lambs[t,
"lambda1"], lambda2 = lambs[t,
"lambda2"], lambda3 = lambs[t,
"lambda3"], nclusts = G, z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]
}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t,
"lambda1"]/100, penalize.diagonal = FALSE)$wi)
})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats,
penalty = ifelse(method == "GGL",
"group", "fused"), penalize.diagonal = FALSE,
lambda1 = lambs[t, "lambda1"]/100,
lambda2 = lambs[t, "lambda2"]/50/1000,
return.whole.theta = TRUE)$theta, FUN = adj)
} else if (method == "RCM") {
arrayRes <- randCov(x = subDats, lambda1 = lambs[t,
"lambda1"]/100, lambda2 = lambs[t,
"lambda2"]/50, lambda3 = lambs[t,
"lambda3"]/1e+05)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]
}), FUN = adj)
}
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ",
lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ",
lambs[t, "lambda3"]))
return(NULL)
})
return(listRes)
}
parallel::stopCluster(cl)
} else {
nets <- lapply(1:nrow(lambs), FUN = function(t) {
tryCatch({
if (method == "RCCM") {
arrayRes <- rcm::rccm(subDats, lambda1 = lambs[t,
"lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G,
z0s = z0s)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]
}), FUN = adj)
} else if (method == "GLasso") {
listRes <- lapply(subDats, FUN = function(x) {
adj(glasso::glasso(cov(x), rho = lambs[t,
"lambda1"]/100, penalize.diagonal = FALSE)$wi)
})
} else if (method %in% c("GGL", "FGL")) {
listRes <- lapply(JGL::JGL(Y = subDats, penalty = ifelse(method ==
"GGL", "group", "fused"),
penalize.diagonal = FALSE, lambda1 = lambs[t,
"lambda1"]/100, lambda2 = lambs[t,
"lambda2"]/50/1000, return.whole.theta = TRUE)$theta,
FUN = adj)
} else if (method == "RCM") {
arrayRes <- randCov(x = subDats, lambda1 = lambs[t,
"lambda1"]/100, lambda2 = lambs[t,
"lambda2"]/50, lambda3 = lambs[t,
"lambda3"]/1e+05)$Omegas
listRes <- lapply(lapply(1:K, FUN = function(k) {
arrayRes[, , k]
}), FUN = adj)
}
return(listRes)
}, error = function(e) {
warning(paste0("stARS failed for lambda1 = ",
lambs[t, "lambda1"], ", lambda2 = ",
lambs[t, "lambda2"], ", lambda3 = ",
lambs[t, "lambda3"]))
return(NULL)
})
})
}
return(nets)
})
warnings()
i = 1
subDats <- lapply(1:K, FUN = function(k) {
datf[[k]][keepInds[[k]][, i], ]
})
t = 1
k = 1
arrayRes <- rcm::rccm(subDats, lambda1 = lambs[t,
"lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G,
z0s = z0s)$Omegas
arrayRes <- rccm::rccm(subDats, lambda1 = lambs[t,
"lambda1"], lambda2 = lambs[t, "lambda2"],
lambda3 = lambs[t, "lambda3"], nclusts = G,
z0s = z0s)$Omegas
lambs[t,
"lambda1"]
lambs[t, "lambda2"]
lambs[t, "lambda3"]
View(lambs)
remove.packages('rccm')
devtools::install_github("dilernia/rccm")
unlink('docs/exampleSimulationRCCM_HighMag_cache', recursive = TRUE)
?glasso::glasso
apply(Sl, MARGIN = 3, FUN = function(cMat) {mkSymm(glasso::glasso(cMat, rho = 0.001, start = "warm", w.init = cMat)$wi)})
x <- rccm::rccSim()$simDat
Sl <- sapply(x, cov, simplify = "array")
Omegas2 <- apply(Sl, MARGIN = 3, FUN = function(cMat) {mkSymm(glasso::glasso(cMat, rho = 0.001, start = "warm", w.init = cMat)$wi)})
# Function for making almost symmetric matrix symmetric
mkSymm <- function(x) {
return((x + t(x)) / 2)
}
Omegas2 <- apply(Sl, MARGIN = 3, FUN = function(cMat) {mkSymm(glasso::glasso(cMat, rho = 0.001, start = "warm", w.init = cMat)$wi)})
Omegas2 <- apply(Sl, MARGIN = 3, FUN = function(cMat) {mkSymm(glasso::glasso(cMat, rho = 0.001, start = "warm", w.init = cMat, wi.init = solve(cMat))$wi)})
Omegas2 <- spply(1:K, FUN = function(k) {mkSymm(glasso::glasso(Sl[, , k], rho = 0.001, start = "warm", w.init = Sl[, , k], wi.init = solve(Sl[, , k]))$wi)})
# Inputs:
K <- length(x)
G <- nclusts
p <- dim(x[[1]])[2]
Omegas2 <- sapply(1:K, simplify = "array", FUN = function(k) {mkSymm(glasso::glasso(Sl[, , k], rho = 0.001, start = "warm", w.init = Sl[, , k], wi.init = solve(Sl[, , k]))$wi)})
diag(5, 10)
# Function for making almost symmetric matrix symmetric
mkSymm <- function(x) {
return((x + t(x)) / 2)
}
# Inputs:
K <- length(x)
G <- nclusts
p <- dim(x[[1]])[2]
Sl <- sapply(x, cov, simplify = "array")
nks <- sapply(x, nrow)
iSl <- sapply(1:K, simplify = "array", FUN = function(k) {
pMat <- solve(Sl[, , k])
minEig <- min(eigen(pMat)$values)
dVal <- ifelse(minEig > 0, minEig, abs(minEig) + 0.001)
return(pMat + diag(dVal, p))
})
apply(iSl, MARGIN = 3, FUN = function(x){min(eigen(x)$values)})
1e-8
